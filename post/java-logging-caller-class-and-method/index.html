<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <title>
    How Java logging frameworks determine caller class and method name | 127.0.0.1
  </title>

  
  <meta name="viewport" content="width=device-width,user-scalable=yes,maximum-scale=1.5,initial-scale=1">

  
  <link rel="canonical" href="http://127001.me/post/java-logging-caller-class-and-method/"/>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon144.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/hljs/atelier-heath-light.css">
  <link rel="stylesheet" href="/css/theme.css">

  
  <link href="http://127001.me/index.xml" rel="alternate" type="application/rss+xml" title="127.0.0.1"/>
  <link href="http://127001.me/index.xml" rel="feed" type="application/rss+xml" title="127.0.0.1"/>

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-82090130-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>

<div class="container">
  <header role="banner">
    <div class="title-block">
      <span class="title-span">
        <a class="title" href="http://127001.me/">
          <span class="user">me</span>@<span class="host">127.0.0.1</span>:<span class="cwd">~</span><span class="prompt">$</span> <span class="cursor">_</span>
        </a>
        
          
        
      </span>
    </div>
  </header>


<main id="single" role="main">
  <div class="post-title-wrapper">
  <h1>How Java logging frameworks determine caller class and method name </h1>

  <div class="post-title-meta">
    Apr 8, 2014
  </div>
</div>

  <article>
    <div class="paragraph">
<p>This post describes how java logging frameworks (<em>log4j</em>, for example) know a point (concrete class and method name), where logging statement has been invoked.</p>
</div>
<div class="paragraph">
<p>I decided to write this post, because quite often I communicate with developers, who do not understant what is the cost of writing caller information to logs, and why such high cost is imposed.</p>
</div>
<div class="sect1">
<h2 id="cut">Brief <em>log4j</em> configuration and usage overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Logger is identified by its name (a.k.a. category). Common myth here, is that logger is somehow connected with the class it is declared in. The myth is based on the signature of the factory method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private static final Logger log = LogManager.getLogger(MyService.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>but that&#8217;s just a shortcut for</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">LogManager.getLogger(MyService.class.getName());</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_category_vs_caller_class_name">Category vs Caller class name</h3>
<div class="paragraph">
<p>It is important to understand the difference between logger category (placeholder <code>%c</code> in <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html"><code>PatternLayout</code></a>) and caller class name (<code>%C</code>).</p>
</div>
<div class="paragraph">
<p>Consider the following example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package com.my.company.name;
public class MyService {

  private static final Logger log1 = LogManager.getLogger(MyService.class);
  private static final Logger log2 = LogManager.getLogger("blah-blah");

  public void f() {
    log1.debug("I'm log1");
    log2.debug("I'm log2");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When call to <strong>f()</strong> is performed while logger is configured with pattern <code>%c - %m%n</code>, log will contain</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>com.my.company.name.MyService - I'm log1
blah-blah - I'm log2</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, if pattern is <code>%C - %m%n</code>, we&#8217;ll get</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>com.my.company.name.MyService - I'm log1
com.my.company.name.MyService - I'm log2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Despite of being named <em>blah-blah</em>, the second logger somehow determined its caller class name.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_does_it_work">How does it work?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before JVM enters any method, it records the point from which this method is invoked to be able to return to that same point later, after the method returns. Let&#8217;s look at simple example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {
  public static void main(String[] args) { a(); }
  static void a() { getCallerInfo(); }
  static void getCallerInfo() { b(); }
  static void b() { throw new RuntimeException(); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Method <code>b()</code> throws an exception. Exception reaches the very top without being caught and its stacktrace gets printed to <code>System.err</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Exception in thread "main" java.lang.RuntimeException
 at Example.b(Example.java:7)
 at Example.getCallerInfo(Example.java:6)
 at Example.a(Example.java:5)
 at Example.main(Example.java:4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Having that stacktrace it is easy to say, that method <code>getCallerInfo()</code> has been called from method <code>a()</code>. So if we could get that stacktrace in runtime somehow and analyze it, we could find an invocation point for any method in our application.</p>
</div>
<div class="sect2">
<h3 id="_obtaining_stacktrace">Obtaining stacktrace</h3>
<div class="paragraph">
<p>There are few ways to get stacktrace in Java: <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#getStackTrace--"><code>Thread.getStackTrace</code></a> and <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#getStackTrace--"><code>Throwable.getStackTrace()</code></a>. Both methods return array of <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StackTraceElement.html"><code>StackTraceElement</code></a>.</p>
</div>
<div class="sect3">
<h4 id="_throwable_getstacktrace">Throwable.getStackTrace()</h4>
<div class="paragraph">
<p>Usage is as simple as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">new Throwable().getStackTrace();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stacktrace gets filled in when <code>Throwable</code> is created, so no need to throw it. Moreover, it is possible to reuse the same <code>Throwable</code> instance calling <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#fillInStackTrace--"><code>fillInStacktrace()</code></a> to refresh stacktrace when needed (of course, keeping in mind possible race conditions if shared across threads).
Under the hood native method <code>Throwable.fillInStackTrace(int dummy)</code> is invoked eventually.</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread_getstacktrace">Thread.getStackTrace()</h4>
<div class="paragraph">
<p>Usage is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Thread.currentThread().getStackTrace();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although a bit cleaner, this method does not give other benefits and is a bit slower (it has to check, whether stack trace is obtained for current thread of for some other thread, doing necessary security checks if required). And in the end stacktrace is obtained from new <strong>Exception</strong> instance in a way described above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_stacktrace">Parsing stacktrace</h3>
<div class="paragraph">
<p>So we got array of <code>StackTraceElement</code>. We need to iterate through that array and find such element whichs declaring class and method name properties satisfy some criteria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">"debug".equals(methodName) &amp; "my.company.Logger".equals(declaringClass)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is very simple straightforward implementation of a logger, which knows everything about its caller.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Logger {

  /**
   * Log message to stderr along with the caller class and method name.
   * @param msg message to log
   */
  public final void log(String msg) {
    StackTraceElement[] stackTrace = new Throwable().getStackTrace();
    // Index of StackTraceElement in stacktrace, where our logger appears.
    int i = getSelfElementIndex(stackTrace, this.getClass());
    // Caller is the next item down the stack.
    StackTraceElement caller = stackTrace[i + 1];
    System.err.println(caller.getClassName() + "." + caller.getMethodName() + ": "
       + msg);
  }

  private int getSelfElementIndex(StackTraceElement[] stackTrace) {
    for (int i = 0; i &lt; stackTrace.length; i++) {
      StackTraceElement el = stackTrace[i];
      // We don't need to check method name, our logger has only one method.
      if (el.getClassName().equals(this.getClass().getName())) {
        return i;
      }
    }
    throw new IllegalStateException("Logger doesn't appear in stacktrace");
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_about_log4j">What about <em>log4j</em></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Of course, it&#8217;s a bit more complicated than that. Good points to start investigation are</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.apache.log4j.spi.LocationInfo</code></p>
</li>
<li>
<p><code>org.apache.log4j.helpers.PatternParser.LocationPatternConverter</code></p>
</li>
</ul>
</div>
</div>
</div>
  </article>
  
<div class="post-tags-list">
  <span class="label"><i class="fa fa-tags"></i></span>
  
  <a href="/tags/java">java</a>&nbsp;
  
  <a href="/tags/log4j">log4j</a>&nbsp;
  
  <a href="/tags/stacktrace">stacktrace</a>&nbsp;
  
</div>


</main>



<article class="comments">
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            
        };
        (function() {
            var inIFrame = function() {
                var iframe = true;
                try { iframe = window.self !== window.top; } catch (e) {}
                return iframe;
            };
            if (inIFrame()) return;
            var disqus_js = '//127001me.disqus.com/embed.js';
            var d = document, s = d.createElement('script');
            s.src = disqus_js; s.async = true;
            s.setAttribute('data-timestamp', +new Date());
            var b = false, l = function() {
                if (b) return;
                (d.head || d.body).appendChild(s); b = true;
            }
            var t = d.getElementById('disqus_thread');
            s.onerror = function(e) {
                if (sessionStorage.getItem('failure-note')) return;
                t.innerText = 'Disqus failed to load';
                t.style.border = '1px dashed';
                t.style.padding = '.5em';
                t.style.background = 'lightyellow';
                sessionStorage.setItem('failure-note', true);
            };
            
            if (location.hash.match(/^#comment/)) return l();
            var c = function() {
                if (b) return;
                var rect = t.getBoundingClientRect();
                if (rect.top < window.innerHeight && rect.bottom >= 0) l();
            };
            window.addEventListener('load', c);
            d.addEventListener('scroll', c);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>


<footer role="contentinfo">
  <div class="footer-content">
    
    <div class="footer-copyright-info">
      Â© 2016 Dmytro Kostiuchenko
    </div>
    

    <div class="footer-social-buttons">
      
      <a href="https://github.com/edio" title="GitHub"><i class="fa fa-github"></i></a>
      
      
      <a href="https://ua.linkedin.com/in/dmytro-kostiuchenko-7b046b14" title="Linkedin"><i class="fa fa-linkedin-square"></i></a>
      
      
      
      
    </div>
  </div>
</footer>
</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>


