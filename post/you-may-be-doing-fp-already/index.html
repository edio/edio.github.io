<!doctype html><html lang=en-us><head><meta charset=utf-8><title>You may be doing FP already | 127.0.0.1</title><meta name=viewport content="width=device-width,user-scalable=yes,maximum-scale=1.5,initial-scale=1"><link rel=canonical href=http://127001.me/post/you-may-be-doing-fp-already/><link rel=apple-touch-icon-precomposed sizes=144x144 href=/favicon144.png><link rel="shortcut icon" href=/favicon.png><link rel=stylesheet href=http://127001.me/css/bundle.min.css><link href=http://127001.me/index.xml rel=alternate type=application/rss+xml title=127.0.0.1><link href=http://127001.me/index.xml rel=feed type=application/rss+xml title=127.0.0.1><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-82090130-1','auto');ga('send','pageview');</script></head><div class=container><header role=banner><div class=title-block><span class=title-span><a class=title href=http://127001.me/><span class=user>me</span>@<span class=host>127.0.0.1</span>:<span class=cwd>~</span><span class=prompt>$</span> <span class=cursor>_</span></a></span></div></header><main id=single role=main><div class=post-title-wrapper><div style=display:flex><div style=flex:1><div class=post-category><a href=/category/software-engineering>/software engineering/</a></div></div><div class=post-date>Feb 10, 2020</div></div><h1>You may be doing FP already</h1><div style=display:flex><div style=flex:1><div class=post-tags-list><a href=/tags/fp>#fp</a>&nbsp;
<a href=/tags/java>#java</a>&nbsp;
<a href=/tags/oop>#oop</a>&nbsp;
<a href=/tags/scala>#scala</a>&nbsp;</div></div></div></div><article><div class=paragraph><p>Functional programming (FP) has been a somewhat hot topic in recent years in my surroundings. Although in my <em>close</em>
surroundings people are usually not very zealous or overly excited, I do notice sometimes talks, discussions and vocally
expressed opinions where <em>tremendous</em> benefits of FP over other paradigms are claimed, through presenting FP as a
fundamentally new approach to writing code, opposite to, say, OOP. Some go as far as saying, that one must fully ditch
OOP and all related experience because it&#8217;s all just a mistake.</p></div><div class=paragraph><p>Such extreme claims are rarely challenged. When a person with an OOP background gets involved in any FP-related
discussion, it quickly gets overwhelmed with new unfamiliar vocabulary: algebras, monads, semigroups, functors, type
classes&#8230;&#8203; And I start questioning intents of those claims — are they made to make people shift to FP, or to prove, that
some definition of FP is better than some definition of OOP?</p></div><div class=paragraph><p>With this post, I hope to show that FP can be seen as an evolutionary step, a generalization over practices we already
consider the best in OOP paradigm. And if viewed like this, it can be useful even when adopted gradually. I hope this
point of view will persuade programmers to look into FP and to borrow new techniques from it to improve non-FP code.</p></div><div class=sect1><h2 id=cut>FP concepts we already use in OOP</h2><div class=sectionbody><div class=paragraph><p>I want to examine concepts, that are claimed (by some) to be unique to FP but are actually used in non-FP code too.</p></div><div class=sect2><h3 id=_pure_functions>Pure functions</h3><div class=paragraph><p>And for starters let&#8217;s examine what probably is considered the core concept of FP — pure functions.</p></div><div class=paragraph><p>A pure function must satisfy 2 properties:</p></div><div class=ulist><ul><li><p>its return value is the same for the same arguments,</p></li><li><p>its evaluation has no side effects.</p></li></ul></div><div class=paragraph><p>Let&#8217;s consider a simple application.</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">public class TravellingApp {

  private static void errExit(Throwable t, int code) {
    System.err.println(t.getMessage());
    System.exit(code);
  }

  public static void main(String[] args) {
    try {
      Cli cli = parseCli(args);
    } catch (CliParsingException e) {
      System.out.println(usageText);
      errExit(e, 1);
    }

    Config config
    try {
      config = readConfig(cli.configPath)
    } catch (IOException ioe) {
      errExit(ioe, 2);
    }

    try {
      travelAroundTheWorld(config)
    } catch (WorldIsFlatException wife) {
      errExit(wife, 3);
    } catch (TimeoutException te) {
      errExit(te, 4);
    }
    ...
  }
}</code></pre></div></div><div class=paragraph><p>Even if we ignore verbose errors handling this code is horrible because it is hard to test. One could assign custom
<code>PrintStream</code> to <code>System.err</code> and <code>System.out</code> to verify what program prints, but verifying exit code becomes super hard
(on top of that, <code>System.exit()</code> will cause JVM running tests to exit).</p></div><div class=paragraph><p>A simple way around that is moving all the logic from <code>main</code> to some <code>run</code> method with a more testable signature, where
exit code is returned — <code>int run(String[] args)</code>. To avoid the global mutable state in our testing code (<code>System.out</code> and
<code>System.err</code> values), we may want to pass <code>PrintStream</code> instances in our <code>run()</code>, and we&#8217;ll end up with this:</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">public class TravellingApp {

  private static int exit(PrintStream ps, Throwable t, int code) {
    ps.println(t.getMessage());
    return code;
  }

  public static void main(String[] args) {
    System.exit(run(args, System.out, System.err));
  }

  public static int run(String[] args, PrintStream out, PrintStream err) {
    try {
      Cli cli = parseCli(args);
    } catch (CliParsingException e) {
      out.println(usageText);
      return exit(err, e, 1);
    }
    ...
    return 0;
  }
}</code></pre></div></div><div class=paragraph><p>Now, looking at this code, an OOP programmer would say: <em>«run() is more testable»</em>. An FP programmer would say:
<em>«run() has fewer side-effects»</em>.</p></div><div class=paragraph><p><code>run()</code> is still not <em>pure</em> because it changes the state of its input arguments <code>out</code> and <code>err</code>. One could make it pure by
making <code>run()</code> to return a tuple (or for the lack of those in Java, a class) of an int to serve as an exit code and 2
strings to be printed to <em>out</em> and <em>err</em> streams. But I believe, an average OOP programmer would not go that far.</p></div><div class=paragraph><p>At this point, it&#8217;s anyway easy to observe, that <em>testability</em> is achieved through eliminating side-effects. Pureness is
a stricter requirement, of course, in OOP code you&#8217;d see many more testable functions than pure functions (or if you
wish <em>computations</em>). But pure computations do happen in the OOP code.</p></div><div class=paragraph><p>It is interesting, that <em>testability</em> lies in the heart of an extremely popular technique among OOP programmers —
dependency injection (DI). I still occasionally meet people, who associate DI with magical frameworks like Spring and
Guice. It is, however, a very simple technique: <em>inject all dependencies needed for your computation, do not let your
computations produce those dependencies</em>.</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">class NonDiService {
  Dao dao = new Dao();
}

class DiService{
  ...
  DiService(Dao dao) {
    this.dao = dao;
  }
}</code></pre></div></div><div class=paragraph><p><code>service = new NonDiService()</code> and <code>service = new DiService(dao)</code> are manifestations of the same pattern we saw with
<code>main(args)</code> and <code>run(args, out, err)</code>, and I hope it is obvious that DI converges to pure computations and may
occasionally result in pure computations.</p></div><div class=paragraph><p>OOP does not require <em>pure</em> computations, it is usually enough to have a <em>testable</em> computation. The set of <em>testable</em>
computations is a much broader category than the set of <em>pure</em> computations. But</p></div><div class="admonitionblock tip"><table><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><em>testability</em>, like <em>pureness</em>, is achieved through eliminating side-effects, and occasionally pure computations
happen in OOP code.</td></tr></table></div></div><div class=sect2><h3 id=_immutable_data_structures>Immutable data structures</h3><div class=paragraph><p>Immutable data structures are an inherent feature of FP. However, saying that you don&#8217;t have this in OOP would be just
silly. Here are just a few examples from Java world:</p></div><div class=ulist><ul><li><p>Joshua Bloch in his <em>Effective Java</em> suggests minimizing mutability<sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup>,</p></li><li><p>extremely popular AST sugaring library Lombok offers special annotation for generating immutable value classes <code>@Value</code> <sup class=footnote>[<a id=_footnoteref_2 class=footnote href=#_footnotedef_2 title="View footnote.">2</a>]</sup>,</p></li><li><p>in many companies (most I worked for) Java CI pipeline integrates some static analyzers, like FindBugs, that will
remind you to make defensive copies of non-primitive types passed as arguments to avoid unexpected mutability,</p></li><li><p>immutable collections are offered by standard library and many 3rd-party libraries (Guava, Eclipse collections)&#8230;&#8203;</p></li></ul></div><div class=paragraph><p>Immutability may be not as ubiquitous in other paradigms as it is in FP, but it is certainly not an alien there.</p></div><div class="admonitionblock tip"><table><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content>OOP programmers are well familiar with the concept of immutability and understand its benefits and its price very
well.</td></tr></table></div></div><div class=sect2><h3 id=_avoiding_inheritance>Avoiding inheritance</h3><div class=paragraph><p>In one of his blog posts John A De Goes says<sup class=footnote>[<a id=_footnoteref_3 class=footnote href=#_footnotedef_3 title="View footnote.">3</a>]</sup>, that</p></div><div class=quoteblock><blockquote><div class=paragraph><p>object-oriented programming—by which I mean inheritance hierarchies (typified by the Scala collections inheritance
hierarchy) and subtyping (beyond its use for modeling sum types, modules, and type classes)—isn’t useful.</p></div></blockquote></div><div class=paragraph><p>I won&#8217;t argue with the claim. But I want to highlight, that the target of his claim is inheritance, not, strictly
speaking, OOP. Yes, many books say, that inheritance is one of the pillars of OOP, but some don&#8217;t.</p></div><div class=paragraph><p>Alan Kay, who is considered the inventor of OOP, starts his (quite hard to grok, to be honest) response about inheritance
with this<sup class=footnote>[<a id=_footnoteref_4 class=footnote href=#_footnotedef_4 title="View footnote.">4</a>]</sup>:</p></div><div class=quoteblock><blockquote><div class=paragraph><p>I initially liked the idea — it could be useful — but soon realized that something that would be “mathematically
binding” was really needed because the mechanism itself let too many semantically different things to be “done” (aka
“kluged”) by the programmer.</p></div></blockquote></div><div class=paragraph><p>Polemics about definitions are rarely productive, let&#8217;s see what happens in practice. Joshua&nbsp;Bloch argued for
composition and delegation over inheritance almost 20 years ago too<sup class=footnote>[<a id=_footnoteref_5 class=footnote href=#_footnotedef_5 title="View footnote.">5</a>]</sup>. And maybe, 10 years ago I would still occasionally see 7 levels of inheritance in the new
code, but people don&#8217;t do this anymore. I&#8217;ve seen Java projects, where programmers preferred code duplication over
inheritance, and they believed they were doing OOP. Modern non-FP languages (Go, Rust) do not even offer this design
facility.</p></div><div class="admonitionblock tip"><table><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content>Inheritance just proved itself practically inconvenient in <em>many</em> cases, and this is not unique to FP.</td></tr></table></div></div></div></div><div class=sect1><h2 id=_how_oop_design_patterns_relate_to_fp>How OOP design patterns relate to FP</h2><div class=sectionbody><div class=sect2><h3 id=_factory>Factory</h3><div class=paragraph><p>Let&#8217;s consider the infamous <em>Factory</em> pattern (<em>Abstract Factory</em> to be
precise)<sup class=footnote>[<a id=_footnoteref_6 class=footnote href=#_footnotedef_6 title="View footnote.">6</a>]</sup>. It is useful when we have to construct an
object from some data. However, there are 2 complications:</p></div><div class=ulist><ul><li><p>the data is scattered through the different stages of program execution (part of the data may be even available in
compile-time only); and</p></li><li><p>the object has to be constructed at the execution stage, where we don&#8217;t have access to full data.</p></li></ul></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">interface ShipFactory {
  Ship build(int capacity);
}

class BoatFactory implements ShipFactory {
  BoatFactory(WoodSpecies ws) { ... }
  public Ship build(int capacity) { ... }
}

class YachtFactory implements ShipFactory {
  YachtFactory(DriveType dt, PremiumPackage pp) { ... }
  public Ship build(int capacity) { ... }
}

class TravellingApp {
  public static void main(String[] args) {
    ShipType st = getShipType(args);

    ShipFactory sf;
    switch st { <i class=conum data-value=1></i><b>(1)</b>
      case Galley:
        BoatConfig c = readBoatConfig(getConfigPath());
        sf = new BoatFactory(c.woodSpecies); <i class=conum data-value=2></i><b>(2)</b>
        break;
      case Yacht:
        YachtConfig c = readYachtConfig(getConfigPath());
        sf = new YachtFactory(c.driveType, c.premiumPackage); <i class=conum data-value=2></i><b>(2)</b>
        break;
    }

    assembleExpeditions(sf);
  }

  static void assembleExpeditions(ShipFactory sf) {
    while(int newCrewSize = readCrewSizeBlocking() &gt; 0) {
      Ship s = sf.build(newCrewSize); <i class=conum data-value=3></i><b>(3)</b>
      sail(s);
    }
  }
}</code></pre></div></div><div class=paragraph><p>At <i class=conum data-value=3></i>we no longer care about the concrete factory type and <i class=conum data-value=3></i>may happen in a different class,
be invoked in a different thread and much later, than <i class=conum data-value=2></i>where a factory is constructed according to the
desired type we inspect at <i class=conum data-value=1></i>.</p></div><div class=paragraph><p>Combined together <i class=conum data-value=2></i>and <i class=conum data-value=3></i>form a curried function</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">new BoatFactory(c.woodSpecies).build(newCrewSize);
new YachtFactory(c.driveType, c.premiumPackage).build(newCrewSize);</code></pre></div></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=scala class="language-scala hljs">def boatFactory(ws: WoodSpecies)(crewSize: Int): Ship
def yachtFactory(dt: DriveType, pp: PremiumPackage)(crewSize: Int): Ship</code></pre></div></div><div class=paragraph><p>Notice, that in the original OOP code <i class=conum data-value=1></i>and <i class=conum data-value=2></i>can&#8217;t be scattered in code like <i class=conum data-value=2></i>and <i class=conum data-value=3></i>can. If we wanted to do that, we&#8217;d need another factory (and some refactoring to make types play
well, but that&#8217;s a different story). This is how you get <code>ShipFactoryFactory</code>, and one can continue this infinitely
long. An important outcome here is that</p></div><div class="admonitionblock tip"><table><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content>a factory is 2 functions chained together in a polymorphic curried function.</td></tr></table></div><div class=paragraph><p>Composition of factories like functions is also technically possible, however, it rarely happens in practice (and is
frowned upon) due to convoluted mind-bending semantics and the amount of boilerplate code such composition generates.</p></div></div><div class=sect2><h3 id=_strategy>Strategy</h3><div class=paragraph><p><em>Strategy</em> pattern<sup class=footnote>[<a id=_footnoteref_7 class=footnote href=#_footnotedef_7 title="View footnote.">7</a>]</sup> is a simple example because it is just a
function passed into another function. <em>Strategy</em> is the way OOP does function pointers given the lack of such
abstraction as function.</p></div><div class=paragraph><p>I picked this example only to illustrate an interesting feature of the OOP patterns.</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">interface NavigationStrategy {
  Route navigate(Point origin, Point destination);
}

class UseWindForceStrategy implements NavigationStrategy {
  UseWindForceStrategy(Forecast f, float desiredEfficiency) { ... }
  public Route navigate(Point origin, Point destination) { ... }
}

class ShortestRouteStrategy implements NavigationStrategy {
  ShortestRouteStrategy() { ... }
  public Route navigate(Point origin, Point destination) { ... }
}</code></pre></div></div><div class=paragraph><p>A strategy may be parameterized on creation. This makes it very similar to <em>Factory</em> — it can be represented as 2
functions chained into a curried function.</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">new UseWindForceStrategy(forecast, efficiency).navigate(from, to);</code></pre></div></div><div class=paragraph><p>However an OOP programmer wouldn&#8217;t use a factory where strategy is expected! OOP patterns differ not only by how the
computation is performed, but also by the ways these computations can be composed with the rest of the code and the ways
these computations are mapped to application&#8217;s business domain. <em>Adapter</em> or <em>Decorator</em> would immediately tell you, how
it is composed with the rest of the code, and that it&#8217;s likely a technical artifact that can not be mapped to the
business domain, unlike f.ex. <em>Strategy</em>.</p></div><div class="admonitionblock tip"><table><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content>OOP patterns convey a wide(r) set of meanings, and this is one of the reasons why there are so many of them.</td></tr></table></div></div><div class=sect2><h3 id=_command>Command</h3><div class=paragraph><p>My favorite would probably be <em>Command</em>. Here you have algebras, suspension of side-effects, representing programs as
values and even quite decent composability.</p></div><div class=listingblock><div class=content><pre class="highlightjs highlight"><code data-lang=java class="language-java hljs">inteface Command {
  void run();
}
class Action1Command implements Command { ... }
class Action2Command implements Command { ... }

class Dispatcher {
  void execute(Command c) { ... }
}
class Service {
  Command doAction1() {  ...; return new Action1Command(); }
  Command doAction2() {  ...; return new Action2Command(); }
  ...
}

List&lt;Command&gt; commands = ...;
Service srv = new Service();
Service dispatcher = new Dispatcher();

...

commands.add(srv.doAction1());
commands.add(srv.doAction2());

...

for (Command cmd: commands) {
  dispatcher.execute(cmd);
}</code></pre></div></div><div class=paragraph><p>There were real problems that had to be solved, and all those OOP patterns are perfectly valid solutions. I find it
interesting, that although OOP abstractions are built using entirely different building blocks, solutions produced in
the scope of this paradigm are well aligned with solutions that FP paradigm offers.</p></div><div class=paragraph><p>I guess my point is&#8230;&#8203;</p></div></div></div></div><div class=sect1><h2 id=_dont_make_fp_look_less_approachable_than_it_is>Don&#8217;t make FP look less approachable than it is</h2><div class=sectionbody><div class=paragraph><p>Writing programs using only pure function and immutable data structures may have some benefits. But it does not mean,
that there&#8217;s nothing in between the side-effectfull mutable OOP and idealistic FP. When it comes to solving real-world
problems with code, FP or OOP is a false dichotomy.</p></div><div class=paragraph><p>It is good to be influenced by FP and take the best of it, where it suits you. Already mentioned Rust and Go do not
offer inheritance, allow higher-order functions, employ error propagation models that result in complete functions, Rust
allows parametric polymorphism and offers many monadic structures in its standard library. Both are far from pure FP,
and yet, both are used successfully to solve real problems.</p></div><div class=paragraph><p>And if you have not tried FP but been curious (and you should always be), start small. You&#8217;d better learn FP using a
language that helps you, but you don&#8217;t need to rewrite 10 years old legacy project at work in a new language to get
benefits of FP. Techniques that you acquire through practicing FP may improve your unpure non-functional Java, Python
or JavaScript code, and, as the title says, quite possibly they already did.</p></div></div></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. Joshua Bloch, <em>Effective Java</em>, Minimize mutability</div><div class=footnote id=_footnotedef_2><a href=#_footnoteref_2>2</a>. Lombok <code>@Value</code> annotation — <a href=https://projectlombok.org/features/Value class=bare>https://projectlombok.org/features/Value</a></div><div class=footnote id=_footnotedef_3><a href=#_footnoteref_3>3</a>. John A. De Goez, <em>Data Modeling in FP vs OOP</em> — <a href=http://degoes.net/articles/fp-vs-oop-part1 class=bare>http://degoes.net/articles/fp-vs-oop-part1</a></div><div class=footnote id=_footnotedef_4><a href=#_footnoteref_4>4</a>. What does Alan Kay think about inheritance — <a href=https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming class=bare>https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming</a></div><div class=footnote id=_footnotedef_5><a href=#_footnoteref_5>5</a>. Joshua Bloch, <em>Effective Java</em>, Favor composition over inheritance</div><div class=footnote id=_footnotedef_6><a href=#_footnoteref_6>6</a>. <a href=https://en.wikipedia.org/wiki/Abstract_factory_pattern class=bare>https://en.wikipedia.org/wiki/Abstract_factory_pattern</a></div><div class=footnote id=_footnotedef_7><a href=#_footnoteref_7>7</a>. <a href=https://en.wikipedia.org/wiki/Strategy_pattern class=bare>https://en.wikipedia.org/wiki/Strategy_pattern</a></div></div></article></main><article class=comments><div id=disqus_thread></div><script>if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!==-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';}else{var disqus_config=function(){};(function(){var inIFrame=function(){var iframe=true;try{iframe=window.self!==window.top;}catch(e){}
return iframe;};if(inIFrame())return;var disqus_js='//127001me.disqus.com/embed.js';var d=document,s=d.createElement('script');s.src=disqus_js;s.async=true;s.setAttribute('data-timestamp',+new Date());var b=false,l=function(){if(b)return;(d.head||d.body).appendChild(s);b=true;}
var t=d.getElementById('disqus_thread');s.onerror=function(e){if(sessionStorage.getItem('failure-note'))return;t.innerText='Disqus failed to load';t.style.border='1px dashed';t.style.padding='.5em';t.style.background='lightyellow';sessionStorage.setItem('failure-note',true);};if(location.hash.match(/^#comment/))return l();var c=function(){if(b)return;var rect=t.getBoundingClientRect();if(rect.top<window.innerHeight&&rect.bottom>=0)l();};window.addEventListener('load',c);d.addEventListener('scroll',c);})();}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article><footer role=contentinfo><div class=footer-content><div class=footer-copyright-info><a href=https://creativecommons.org/licenses/by/4.0/ title="Except where otherwise noted, content on this site is licensed under CC-BY-4.0"><i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i></a>2020 Dmytro Kostiuchenko</div><div class=footer-social-buttons><a href=https://github.com/edio title=GitHub><i class="fa fa-github"></i></a><a href=https://ua.linkedin.com/in/dmytro-kostiuchenko-7b046b14 title=Linkedin><i class="fa fa-linkedin-square"></i></a></div></div></footer></div><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>