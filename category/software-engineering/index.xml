<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>software engineering on 127.0.0.1</title><link>http://127001.me/category/software-engineering/</link><description>Recent content in software engineering on 127.0.0.1</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 Jul 2019 11:00:00 -0400</lastBuildDate><atom:link href="http://127001.me/category/software-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Filtering ScalaTest tests by tags in sbt</title><link>http://127001.me/post/filter-scalatests-by-tags-in-sbt/</link><pubDate>Mon, 08 Jul 2019 11:00:00 -0400</pubDate><guid>http://127001.me/post/filter-scalatests-by-tags-in-sbt/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;em>ScalaTest&lt;/em> lets you tagging your tests with arbitrary tags and then filtering
by tags when executing tests.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>It&amp;#8217;s not immediately obvious though, how to make use of this in &lt;em>sbt&lt;/em>, at least
I couldn&amp;#8217;t find an answer on the very first page in Google or StackOverflow, and
I remember myself looking for a complete solution for quite a while&amp;#8230;&amp;#8203; Solution,
however, is as simple as &lt;em>2&amp;nbsp;+&amp;nbsp;2&lt;/em> (where both twos mean reading
documentation ðŸ˜‰).&lt;/p>
&lt;/div></description></item><item><title>Overloading that is not permitted or Java bridge methods</title><link>http://127001.me/post/java-bridge-methods/</link><pubDate>Mon, 09 May 2016 00:59:08 +0200</pubDate><guid>http://127001.me/post/java-bridge-methods/</guid><description>&lt;div class="paragraph">
&lt;p>Most of my technical interviews for Java developer position include a puzzle, where candidate should implement 2 very
similar interfaces in a single class:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlightjs highlight">&lt;code data-lang="java" class="language-java hljs">// Implement both interfaces in a single class if possible
// Explain why possible or not possible
interface WithPrimitiveInt {
void m(int i);
}
interface WithInteger {
void m(Integer i);
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Sometimes candidates, not being sure about the right answer, are willing to solve the following puzzle instead (I give
it to candidates later anyway):&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlightjs highlight">&lt;code data-lang="java" class="language-java hljs">interface S {
String m(int i);
}
interface V {
void m(int i);
}&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div></description></item><item><title>How Java logging frameworks determine caller class and method name</title><link>http://127001.me/post/java-logging-caller-class-and-method/</link><pubDate>Tue, 08 Apr 2014 23:54:49 +0200</pubDate><guid>http://127001.me/post/java-logging-caller-class-and-method/</guid><description>&lt;div class="paragraph">
&lt;p>This post describes how java logging frameworks (&lt;em>log4j&lt;/em>, for example) know a point (concrete class and method name), where logging statement has been invoked.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>I decided to write this post, because quite often I communicate with developers, who do not understant what is the cost of writing caller information to logs, and why such high cost is imposed.&lt;/p>
&lt;/div></description></item></channel></rss>